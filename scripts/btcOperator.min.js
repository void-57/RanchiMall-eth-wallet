!function(EXPORTS){const btcOperator="object"===typeof module?module.exports:window.btcOperator={},util=btcOperator.util={};util.Sat_to_BTC=value=>parseFloat((value/1e8).toFixed(8)),util.BTC_to_Sat=value=>parseInt(1e8*value);const checkIfTor=btcOperator.checkIfTor=()=>fetch("https://check.torproject.org/api/ip").then((res=>res.json())).then((res=>res.IsTor)).catch((e=>(console.error(e),!1)));let isTor=!1;async function post(url,data,{asText:asText=!1}={}){try{const response=await fetch(url,{method:"POST",mode:"no-cors",headers:{"Content-Type":"application/json"},body:JSON.stringify(data)});if(response.ok)return asText?await response.text():await response.json();throw response}catch(e){throw e}}checkIfTor().then((result=>isTor=result));const APIs=btcOperator.APIs=[{url:"https://api.blockcypher.com/v1/btc/main/",name:"Blockcypher",balance({addr:addr}){return fetch_api(`addrs/${addr}/balance`,{url:this.url}).then((result=>util.Sat_to_BTC(result.balance)))},async block({id:id}){try{let block=await fetch_api(`blocks/${id}`,{url:this.url});return formatBlock(block)}catch(e){console.log(e)}},async broadcast({rawTxHex:rawTxHex,url:url}){try{return(await post(`${url||this.url}pushtx`,{tx:rawTxHex})).hash}catch(e){throw e}}},{url:"https://blockstream.info/api/",name:"Blockstream",hasOnion:!0,onionUrl:"http://explorerzydxu5ecjrkwceayqybizmpjjznk5izmitf2modhcusuqlid.onion/api/",balance({addr:addr,url:url}){return fetch_api(`address/${addr}/utxo`,{url:url||this.url}).then((result=>{const balance=result.reduce(((t,u)=>t+u.value),0);return util.Sat_to_BTC(balance)}))},latestBlock(){return fetch_api("blocks/tip/height",{url:this.url})},tx({txid:txid,url:url}){return fetch_api(`tx/${txid}`,{url:url||this.url}).then((result=>formatTx(result)))},txHex({txid:txid,url:url}){return fetch_api(`tx/${txid}/hex`,{url:url||this.url,asText:!0})},txs({addr:addr,url:url,...args}){let queryParams=Object.entries(args).map((([key,value])=>`${key}=${value}`)).join("&");return queryParams&&(queryParams="?"+queryParams),fetch_api(`address/${addr}/txs${queryParams}`,{url:url||this.url})},async block({id:id,url:url}){try{let blockHash=id;/^[0-9a-f]{64}$/i.test(id)||(blockHash=await fetch_api(`block-height/${id}`,{url:url||this.url,asText:!0}));const block=await fetch_api(`block/${blockHash}`,{url:url||this.url});return formatBlock(block)}catch(e){throw e}},async broadcast({rawTxHex:rawTxHex,url:url}){return post(`${url||this.url}tx`,{tx:rawTxHex},{asText:!0})}},{url:"https://mempool.space/api/",name:"Mempool",balance({addr:addr}){return fetch_api(`address/${addr}`,{url:this.url}).then((result=>util.Sat_to_BTC(result.chain_stats.funded_txo_sum-result.chain_stats.spent_txo_sum)))},latestBlock(){return fetch_api("blocks/tip/height",{url:this.url})},tx({txid:txid}){return fetch_api(`tx/${txid}`,{url:this.url}).then((result=>formatTx(result)))},txHex({txid:txid}){return fetch_api(`tx/${txid}/hex`,{url:this.url,asText:!0})},txs({addr:addr,...args}){let queryParams=Object.entries(args).map((([key,value])=>`${key}=${value}`)).join("&");return queryParams&&(queryParams="?"+queryParams),fetch_api(`address/${addr}/txs${queryParams}`,{url:this.url})},async block({id:id}){try{let blockHash=id;/^[0-9a-f]{64}$/i.test(id)||(blockHash=await fetch_api(`block-height/${id}`,{url:this.url,asText:!0}));const block=await fetch_api(`block/${blockHash}`,{url:this.url});return formatBlock(block)}catch(e){throw e}},async broadcast({rawTxHex:rawTxHex,url:url}){return post(`${url||this.url}tx`,{tx:rawTxHex},{asText:!0})}},{url:"https://blockchain.info/",name:"Blockchain",balance({addr:addr}){return fetch_api(`q/addressbalance/${addr}`,{url:this.url}).then((result=>util.Sat_to_BTC(result)))},unspent({addr:addr,allowUnconfirmedUtxos:allowUnconfirmedUtxos=!1}){return fetch_api(`unspent?active=${addr}`,{url:this.url}).then((result=>formatUtxos(result.unspent_outputs,allowUnconfirmedUtxos)))},tx({txid:txid}){return fetch_api(`rawtx/${txid}`,{url:this.url}).then((result=>formatTx(result)))},txHex({txid:txid}){return fetch_api(`rawtx/${txid}?format=hex`,{url:this.url,asText:!0})},txs({addr:addr,...args}){let queryParams=Object.entries(args).map((([key,value])=>`${key}=${value}`)).join("&");return queryParams&&(queryParams="?"+queryParams),fetch_api(`rawaddr/${addr}${queryParams}`,{url:this.url}).then((result=>result.txs))},latestBlock(){return fetch_api("q/getblockcount",{url:this.url})},async block({id:id}){try{let block;if(/^[0-9a-f]{64}$/i.test(id))block=await fetch_api(`rawblock/${id}`,{url:this.url});else{block=(await fetch_api(`block-height/${id}?format=json`,{url:this.url})).blocks[0]}return formatBlock(block)}catch(e){throw e}},async blockTxs({id:id}){try{let block;if(/^[0-9a-f]{64}$/i.test(id))block=await fetch_api(`rawblock/${id}`,{url:this.url});else{block=(await fetch_api(`block-height/${id}?format=json`,{url:this.url})).blocks[0]}return block.tx}catch(e){}}},{url:"https://coinb.in/api/?uid=1&key=12345678901234567890123456789012&setmodule=bitcoin&request=sendrawtransaction",name:"Coinb.in",broadcast({rawTxHex:rawTxHex}){return new Promise(((resolve,reject)=>{fetch(this.url,{method:"POST",headers:{"Content-Type":"application/x-www-form-urlencoded"},body:"rawtx="+rawTxHex}).then((response=>{console.log(response),response.text().then((resultText=>{let r=resultText.match(/<result>.*<\/result>/);if(r)if(r=r.pop().replace("<result>","").replace("</result>",""),"1"==r){let txid=resultText.match(/<txid>.*<\/txid>/).pop().replace("<txid>","").replace("</txid>","");resolve(txid)}else if("0"==r){let error;error=resultText.includes("<message>")?resultText.match(/<message>.*<\/message>/).pop().replace("<message>","").replace("</message>",""):resultText.match(/<response>.*<\/response>/).pop().replace("<response>","").replace("</response>",""),reject(decodeURIComponent(error.replace(/\+/g," ")))}else reject(resultText);else reject(resultText)})).catch((error=>reject(error)))})).catch((error=>reject(error)))}))}}];btcOperator.util.format={};const formatBlock=btcOperator.util.format.block=async block=>{try{const{height:height,hash:hash,id:id,time:time,timestamp:timestamp,mrkl_root:mrkl_root,merkle_root:merkle_root,prev_block:prev_block,next_block:next_block,size:size}=block,details={height:height,hash:hash||id,time:1e3*(time||timestamp),merkle_root:merkle_root||mrkl_root,size:size};return prev_block&&(details.prev_block=prev_block),next_block&&(details.next_block=next_block[0]),details}catch(e){throw e}},formatUtxos=btcOperator.util.format.utxos=async(utxos,allowUnconfirmedUtxos=!1)=>{try{if(!allowUnconfirmedUtxos&&!utxos||!Array.isArray(utxos))throw{message:"No utxos found",code:1e3};return utxos.map((utxo=>{const{tx_hash:tx_hash,tx_hash_big_endian:tx_hash_big_endian,txid:txid,tx_output_n:tx_output_n,vout:vout,value:value,script:script,confirmations:confirmations,status:{confirmed:confirmed}={}}=utxo;return{confirmations:confirmations||confirmed,tx_hash_big_endian:tx_hash_big_endian||tx_hash||txid,tx_output_n:tx_output_n||vout,value:value,script:script}}))}catch(e){throw e}},formatTx=btcOperator.util.format.tx=async tx=>{try{let{txid:txid,hash:hash,time:time,block_height:block_height,fee:fee,fees:fees,received:received,confirmed:confirmed,size:size,double_spend:double_spend,block_hash:block_hash,confirmations:confirmations,status:{block_height:statusBlockHeight,block_hash:statusBlockHash,block_time:block_time}={}}=tx;if((block_height||statusBlockHeight)&&void 0===confirmations||null===confirmations){confirmations=await multiApi("latestBlock")-(block_height||statusBlockHeight)}const inputs=tx.vin||tx.inputs,outputs=tx.vout||tx.outputs||tx.out;return{hash:hash||txid,size:size,fee:fee||fees,double_spend:double_spend,time:1e3*time||new Date(confirmed||received).getTime()||1e3*block_time||Date.now(),block_height:block_height||statusBlockHeight,block_hash:block_hash||statusBlockHash,confirmations:confirmations,inputs:inputs.map((input=>({index:input.n||input.output_index||input.vout,prev_out:{addr:input.prev_out?.addr||input.addresses?.[0]||input.prev_out?.address||input.addr||input.prevout.scriptpubkey_address,value:input.prev_out?.value||input.output_value||input.prevout.value}}))),out:outputs.map((output=>({addr:output.scriptpubkey_address||output.addresses?.[0]||output.scriptpubkey_address||output.addr,value:output.value||output.scriptpubkey_value})))}}catch(e){throw e}},multiApi=btcOperator.multiApi=async(fnName,{index:index=0,...args}={})=>{try{let triedOnion=!1;for(;index<APIs.length;){if(APIs[index][fnName]&&!(APIs[index].coolDownTime&&APIs[index].coolDownTime>(new Date).getTime()))return await APIs[index][fnName](args);index+=1}if(isTor&&!triedOnion)for(triedOnion=!0,index=0;index<APIs.length;){if(APIs[index].hasOnion&&!(APIs[index].coolDownTime&&APIs[index].coolDownTime>(new Date).getTime()))return await multiApi(fnName,{index:index+1,...args,url:APIs[index].onionUrl});index+=1}throw"No API available"}catch(error){return console.error(error),APIs[index].coolDownTime=(new Date).getTime()+6e5,multiApi(fnName,{index:index+1,...args})}};const fetch_api=btcOperator.fetch=function(api,{asText:asText=!1,url:url="https://blockchain.info/"}={}){return new Promise(((resolve,reject)=>{console.debug(url+api),fetch(url+api).then((response=>{response.ok?(asText?response.text():response.json()).then((result=>resolve(result))).catch((error=>reject(error))):response.json().then((result=>reject(result))).catch((error=>reject(error)))})).catch((error=>reject(error)))}))};const broadcastTx=btcOperator.broadcastTx=rawTxHex=>new Promise(((resolve,reject)=>{console.log("txHex:",rawTxHex);fetch("https://coinb.in/api/?uid=1&key=12345678901234567890123456789012&setmodule=bitcoin&request=sendrawtransaction",{method:"POST",headers:{"Content-Type":"application/x-www-form-urlencoded"},body:"rawtx="+rawTxHex}).then((response=>{console.log(response),response.text().then((resultText=>{let r=resultText.match(/<result>.*<\/result>/);if(r)if(r=r.pop().replace("<result>","").replace("</result>",""),"1"==r){let txid=resultText.match(/<txid>.*<\/txid>/).pop().replace("<txid>","").replace("</txid>","");resolve(txid)}else if("0"==r){let error;error=resultText.includes("<message>")?resultText.match(/<message>.*<\/message>/).pop().replace("<message>","").replace("</message>",""):resultText.match(/<response>.*<\/response>/).pop().replace("<response>","").replace("</response>",""),reject(decodeURIComponent(error.replace(/\+/g," ")))}else reject(resultText);else reject(resultText)})).catch((error=>reject(error)))})).catch((error=>reject(error)))}));Object.defineProperties(btcOperator,{newKeys:{get:()=>{let r=coinjs.newKeys();return r.segwitAddress=coinjs.segwitAddress(r.pubkey).address,r.bech32Address=coinjs.bech32Address(r.pubkey).address,r}},pubkey:{value:key=>key.length>=66?key:64==key.length?coinjs.newPubkey(key):coinjs.wif2pubkey(key).pubkey},address:{value:(key,prefix=void 0)=>coinjs.pubkey2address(btcOperator.pubkey(key),prefix)},segwitAddress:{value:key=>coinjs.segwitAddress(btcOperator.pubkey(key)).address},bech32Address:{value:key=>coinjs.bech32Address(btcOperator.pubkey(key)).address},bech32mAddress:{value:key=>segwit_addr.encode("bc",1,key)}}),coinjs.compressed=!0;const verifyKey=btcOperator.verifyKey=function(addr,key){if(addr&&key)switch(coinjs.addressDecode(addr).type){case"standard":return btcOperator.address(key)===addr;case"multisig":return btcOperator.segwitAddress(key)===addr;case"bech32":return btcOperator.bech32Address(key)===addr;case"bech32m":return btcOperator.bech32mAddress(key)===addr;default:return null}},validateAddress=btcOperator.validateAddress=function(addr){if(!addr)return;let type=coinjs.addressDecode(addr).type;return!!["standard","multisig","bech32","multisigBech32","bech32m"].includes(type)&&type};btcOperator.multiSigAddress=function(pubKeys,minRequired,bech32=!0){if(!Array.isArray(pubKeys))throw"pubKeys must be an array of public keys";if(pubKeys.length<minRequired)throw"minimum required should be less than the number of pubKeys";return bech32?coinjs.pubkeys2MultisigAddressBech32(pubKeys,minRequired):coinjs.pubkeys2MultisigAddress(pubKeys,minRequired)},btcOperator.decodeRedeemScript=function(redeemScript,bech32=!0){let script=coinjs.script(),decoded=bech32?script.decodeRedeemScriptBech32(redeemScript):script.decodeRedeemScript(redeemScript);return decoded?{address:decoded.address,pubKeys:decoded.pubkeys,redeemScript:decoded.redeemscript,required:decoded.signaturesRequired}:null},btcOperator.convert={},btcOperator.convert.wif=function(source_wif,target_version=coinjs.priv){let keyHex=util.decodeLegacy(source_wif).hex;return!keyHex||keyHex.length<66||!/01$/.test(keyHex)?null:util.encodeLegacy(keyHex,target_version)},btcOperator.convert.legacy2legacy=function(source_addr,target_version=coinjs.pub){let rawHex=util.decodeLegacy(source_addr).hex;return rawHex?util.encodeLegacy(rawHex,target_version):null},btcOperator.convert.legacy2bech=function(source_addr,target_version=coinjs.bech32.version,target_hrp=coinjs.bech32.hrp){let rawHex=util.decodeLegacy(source_addr).hex;return rawHex?util.encodeBech32(rawHex,target_version,target_hrp):null},btcOperator.convert.bech2bech=function(source_addr,target_version=coinjs.bech32.version,target_hrp=coinjs.bech32.hrp){let rawHex=util.decodeBech32(source_addr).hex;return rawHex?util.encodeBech32(rawHex,target_version,target_hrp):null},btcOperator.convert.bech2legacy=function(source_addr,target_version=coinjs.pub){let rawHex=util.decodeBech32(source_addr).hex;return rawHex?util.encodeLegacy(rawHex,target_version):null},btcOperator.convert.multisig2multisig=function(source_addr,target_version=coinjs.multisig){let rawHex=util.decodeLegacy(source_addr).hex;return rawHex?util.encodeLegacy(rawHex,target_version):null},btcOperator.convert.bech2multisig=function(source_addr,target_version=coinjs.multisig){let rawHex=util.decodeBech32(source_addr).hex;return rawHex?(rawHex=Crypto.util.bytesToHex(ripemd160(Crypto.util.hexToBytes(rawHex),{asBytes:!0})),util.encodeLegacy(rawHex,target_version)):null},util.decodeLegacy=function(source){var decode=coinjs.base58decode(source),raw=decode.slice(0,decode.length-4),checksum=decode.slice(decode.length-4),hash=Crypto.SHA256(Crypto.SHA256(raw,{asBytes:!0}),{asBytes:!0});if(hash[0]!=checksum[0]||hash[1]!=checksum[1]||hash[2]!=checksum[2]||hash[3]!=checksum[3])return!1;return{version:raw.shift(),hex:Crypto.util.bytesToHex(raw)}},util.encodeLegacy=function(hex,version){var bytes=Crypto.util.hexToBytes(hex);bytes.unshift(version);var checksum=Crypto.SHA256(Crypto.SHA256(bytes,{asBytes:!0}),{asBytes:!0}).slice(0,4);return coinjs.base58encode(bytes.concat(checksum))},util.decodeBech32=function(source){let decode=coinjs.bech32_decode(source);if(!decode)return!1;var raw=decode.data;let version=raw.shift();return raw=coinjs.bech32_convert(raw,5,8,!1),{hrp:decode.hrp,version:version,hex:Crypto.util.bytesToHex(raw)}},util.encodeBech32=function(hex,version,hrp){var bytes=Crypto.util.hexToBytes(hex);return(bytes=coinjs.bech32_convert(bytes,8,5,!0)).unshift(version),coinjs.bech32_encode(hrp,bytes)},btcOperator.getBalance=addr=>new Promise(((resolve,reject)=>{if(!validateAddress(addr))return reject("Invalid address");multiApi("balance",{addr:addr}).then((result=>resolve(result))).catch((error=>reject(error)))}));const BASE_INPUT_SIZE=41,LEGACY_INPUT_SIZE=107,BECH32_INPUT_SIZE=27,BECH32_MULTISIG_INPUT_SIZE=35,SEGWIT_INPUT_SIZE=59,MULTISIG_INPUT_SIZE_ES=351,BASE_OUTPUT_SIZE=9,LEGACY_OUTPUT_SIZE=25,BECH32_OUTPUT_SIZE=23,BECH32_MULTISIG_OUTPUT_SIZE=34,SEGWIT_OUTPUT_SIZE=23;function _redeemScript(addr,key){let decode=coinjs.addressDecode(addr);switch(decode.type){case"standard":return!1;case"multisig":return key?coinjs.segwitAddress(btcOperator.pubkey(key)).redeemscript:null;case"bech32":case"'multisigBech32":return decode.redeemscript;case"bech32m":return decode.outstring;default:return null}}function _sizePerOutput(addr){switch(coinjs.addressDecode(addr).type){case"standard":return BASE_OUTPUT_SIZE+LEGACY_OUTPUT_SIZE;case"bech32":return BASE_OUTPUT_SIZE+BECH32_OUTPUT_SIZE;case"multisigBech32":return BASE_OUTPUT_SIZE+BECH32_MULTISIG_OUTPUT_SIZE;case"multisig":return BASE_OUTPUT_SIZE+SEGWIT_OUTPUT_SIZE;case"bech32m":return BASE_OUTPUT_SIZE+BECH32M_OUTPUT_SIZE;default:return null}}function validateTxParameters(parameters){let invalids=[];if(parameters.senders&&(Array.isArray(parameters.senders)||(parameters.senders=[parameters.senders]),parameters.senders.forEach((id=>validateAddress(id)?null:invalids.push(id))),invalids.length))throw"Invalid senders:"+invalids;if(parameters.privkeys){if(Array.isArray(parameters.privkeys)||(parameters.privkeys=[parameters.privkeys]),parameters.senders.length!=parameters.privkeys.length)throw"Array length for senders and privkeys should be equal";if(parameters.senders.forEach(((id,i)=>{let key=parameters.privkeys[i];verifyKey(id,key)||invalids.push(id),64===key.length&&(parameters.privkeys[i]=coinjs.privkey2wif(key))})),invalids.length)throw"Invalid private key for address:"+invalids}if(Array.isArray(parameters.receivers)||(parameters.receivers=[parameters.receivers]),parameters.receivers.forEach((id=>validateAddress(id)?null:invalids.push(id))),invalids.length)throw"Invalid receivers:"+invalids;if(parameters.change_address&&!validateAddress(parameters.change_address))throw"Invalid change_address:"+parameters.change_address;if(("number"!=typeof parameters.fee||parameters.fee<=0)&&null!==parameters.fee)throw"Invalid fee:"+parameters.fee;if(Array.isArray(parameters.amounts)||(parameters.amounts=[parameters.amounts]),parameters.receivers.length!=parameters.amounts.length)throw"Array length for receivers and amounts should be equal";if(parameters.amounts.forEach((a=>"number"!=typeof a||a<=0?invalids.push(a):null)),invalids.length)throw"Invalid amounts:"+invalids;return parameters}BECH32M_OUTPUT_SIZE=35,btcOperator._redeemScript=_redeemScript,btcOperator.validateTxParameters=validateTxParameters;const createTransaction=btcOperator.createTransaction=({senders:senders,redeemScripts:redeemScripts,receivers:receivers,amounts:amounts,fee:fee,change_address:change_address,fee_from_receiver:fee_from_receiver,allowUnconfirmedUtxos:allowUnconfirmedUtxos=!1,sendingTx:sendingTx=!1,hasInsufficientBalance:hasInsufficientBalance=!1})=>new Promise(((resolve,reject)=>{let total_amount=parseFloat(amounts.reduce(((t,a)=>t+a),0).toFixed(8));const tx=coinjs.transaction();let output_size=addOutputs(tx,receivers,amounts,change_address);addInputs(tx,senders,redeemScripts,total_amount,fee,output_size,fee_from_receiver,allowUnconfirmedUtxos).then((result=>{if(result.change_amount>0&&result.change_amount>result.fee&&(tx.outs[tx.outs.length-1].value=util.BTC_to_Sat(result.change_amount)),fee_from_receiver){let fee_remaining=util.BTC_to_Sat(result.fee);for(let i=0;i<tx.outs.length-1&&fee_remaining>0;i++)fee_remaining<tx.outs[i].value?(tx.outs[i].value-=fee_remaining,fee_remaining=0):(fee_remaining-=tx.outs[i].value,tx.outs[i].value=0);if(fee_remaining>0)return reject("Send amount is less than fee")}let filtered_outputs=[],dust_value=0;tx.outs.forEach((o=>o.value>=546?filtered_outputs.push(o):dust_value+=o.value)),tx.outs=filtered_outputs,result.fee+=util.Sat_to_BTC(dust_value),result.output_size=output_size,result.output_amount=total_amount-(fee_from_receiver?result.fee:0),result.total_size=12+output_size+result.input_size,result.transaction=tx,sendingTx&&result.hasOwnProperty("hasInsufficientBalance")&&result.hasInsufficientBalance?reject({message:"Insufficient balance",...result}):resolve(result)})).catch((error=>reject(error)))}));function addInputs(tx,senders,redeemScripts,total_amount,fee,output_size,fee_from_receiver,allowUnconfirmedUtxos=!1){return new Promise(((resolve,reject)=>{null!==fee?addUTXOs(tx,senders,redeemScripts,fee_from_receiver?total_amount:total_amount+fee,!1,{allowUnconfirmedUtxos:allowUnconfirmedUtxos}).then((result=>{result.fee=fee,resolve(result)})).catch((error=>reject(error))):new Promise(((resolve,reject)=>{fetch("https://api.blockchain.info/mempool/fees").then((response=>{response.ok?response.json().then((result=>resolve(util.Sat_to_BTC(result.regular)))).catch((error=>reject(error))):reject(response)})).catch((error=>reject(error)))})).then((fee_rate=>{let net_fee=12*fee_rate;net_fee+=output_size*fee_rate,(fee_from_receiver?addUTXOs(tx,senders,redeemScripts,total_amount,!1,{allowUnconfirmedUtxos:allowUnconfirmedUtxos}):addUTXOs(tx,senders,redeemScripts,total_amount+net_fee,fee_rate,{allowUnconfirmedUtxos:allowUnconfirmedUtxos})).then((result=>{result.fee=parseFloat((net_fee+result.input_size*fee_rate).toFixed(8)),result.fee_rate=fee_rate,resolve(result)})).catch((error=>reject(error)))})).catch((error=>reject(error)))}))}function addUTXOs(tx,senders,redeemScripts,required_amount,fee_rate,rec_args={allowUnconfirmedUtxos:!1}){return new Promise(((resolve,reject)=>{if(required_amount=parseFloat(required_amount.toFixed(8)),void 0===rec_args.n&&(rec_args.n=0,rec_args.input_size=0,rec_args.input_amount=0),required_amount<=0)return resolve({input_size:rec_args.input_size,input_amount:rec_args.input_amount,change_amount:-1*required_amount});if(rec_args.n>=senders.length)return resolve({hasInsufficientBalance:!0,input_size:rec_args.input_size,input_amount:rec_args.input_amount,change_amount:-1*required_amount});let addr=senders[rec_args.n],rs=redeemScripts[rec_args.n],addr_type=coinjs.addressDecode(addr).type,size_per_input=function(addr,rs){switch(coinjs.addressDecode(addr).type){case"standard":return BASE_INPUT_SIZE+LEGACY_INPUT_SIZE;case"bech32":return BASE_INPUT_SIZE+BECH32_INPUT_SIZE;case"multisigBech32":return BASE_INPUT_SIZE+BECH32_MULTISIG_INPUT_SIZE;case"multisig":switch(coinjs.script().decodeRedeemScript(rs).type){case"segwit__":return BASE_INPUT_SIZE+SEGWIT_INPUT_SIZE;case"multisig__":return BASE_INPUT_SIZE+MULTISIG_INPUT_SIZE_ES;default:return null}default:return null}}(addr,rs);multiApi("unspent",{addr:addr,allowUnconfirmedUtxos:rec_args.allowUnconfirmedUtxos}).then((utxos=>{for(let i=0;i<utxos.length&&required_amount>0;i++){if(1===utxos.length&&rec_args.allowUnconfirmedUtxos)console.log("allowing unconfirmed utxos");else if(!utxos[i].confirmations)continue;var script;if(rs&&rs.length)if(rs.match(/^00/)&&44==rs.length||40==rs.length&&rs.match(/^[a-f0-9]+$/gi)||"multisigBech32"===addr_type){let s=coinjs.script();s.writeBytes(Crypto.util.hexToBytes(rs)),s.writeOp(0),s.writeBytes(coinjs.numToBytes(utxos[i].value.toFixed(0),8)),script=Crypto.util.bytesToHex(s.buffer)}else script=rs;else script=utxos[i].script;tx.addinput(utxos[i].tx_hash_big_endian,utxos[i].tx_output_n,script,4294967293),rec_args.input_size+=size_per_input,rec_args.input_amount+=util.Sat_to_BTC(utxos[i].value),required_amount-=util.Sat_to_BTC(utxos[i].value),fee_rate&&(required_amount+=size_per_input*fee_rate)}rec_args.n+=1,addUTXOs(tx,senders,redeemScripts,required_amount,fee_rate,rec_args).then((result=>resolve(result))).catch((error=>reject(error)))})).catch((error=>reject(error)))}))}function addOutputs(tx,receivers,amounts,change_address){let size=0;for(let i in receivers)tx.addoutput(receivers[i],amounts[i]),size+=_sizePerOutput(receivers[i]);return tx.addoutput(change_address,0),size+=_sizePerOutput(change_address),size}function tx_fetch_for_editing(tx){return new Promise(((resolve,reject)=>{"string"==typeof tx&&/^[0-9a-f]{64}$/i.test(tx)?getTx.hex(tx).then((txhex=>resolve(deserializeTx(txhex)))).catch((error=>reject(error))):resolve(deserializeTx(tx))}))}btcOperator.addInputs=addInputs,btcOperator.addUTXOs=addUTXOs,btcOperator.addOutputs=addOutputs,btcOperator.tx_fetch_for_editing=tx_fetch_for_editing;btcOperator.extractLastHexStrings=function(arr){const result=[];for(let i=0;i<arr.length;i++){const innerArray=arr[i];if(innerArray.length>0){const lastHexString=innerArray[innerArray.length-1];result.push(lastHexString)}}return result};btcOperator.editFee=function(tx_hex,new_fee,private_keys,change_only=!0){return new Promise(((resolve,reject)=>{Array.isArray(private_keys)||(private_keys=[private_keys]),tx_fetch_for_editing(tx_hex).then((tx=>{parseTransaction(tx).then((tx_parsed=>{if(tx_parsed.fee>=new_fee)return reject("Fees can only be increased");var edit_output_address=new Set;!0===change_only?tx_parsed.inputs.forEach((inp=>edit_output_address.add(inp.address))):!1===change_only?tx_parsed.outputs.forEach((out=>edit_output_address.add(out.address))):"string"==typeof change_only?edit_output_address.add(change_only):Array.isArray(change_only)&&change_only.forEach((id=>edit_output_address.add(id)));let inc_fee=util.BTC_to_Sat(new_fee-tx_parsed.fee);if(inc_fee<219)return reject("Insufficient additional fee. Minimum increment: 219");for(let i=tx.outs.length-1;i>=0&&inc_fee>0;i--)if(edit_output_address.has(tx_parsed.outputs[i].address)){let current_value=tx.outs[i].value;current_value instanceof BigInteger&&(current_value=current_value.intValue()),current_value>inc_fee?(tx.outs[i].value=current_value-inc_fee,inc_fee=0):(inc_fee-=current_value,tx.outs[i].value=0)}if(inc_fee>0){let max_possible_fee=util.BTC_to_Sat(new_fee)-inc_fee;return reject(`Insufficient output values to increase fee. Maximum fee possible: ${util.Sat_to_BTC(max_possible_fee)}`)}tx.outs=tx.outs.filter((o=>o.value>=546));let wif_keys=[];for(let i in tx.ins){var addr=tx_parsed.inputs[i].address,value=util.BTC_to_Sat(tx_parsed.inputs[i].value);let addr_decode=coinjs.addressDecode(addr);var privKey=private_keys.find((pk=>verifyKey(addr,pk)));if(!privKey)return reject(`Private key missing for ${addr}`);const rs=_redeemScript(addr,privKey);var script;if(!1===rs?wif_keys.unshift(privKey):wif_keys.push(privKey),rs&&rs.length)if(rs.match(/^00/)&&44==rs.length||40==rs.length&&rs.match(/^[a-f0-9]+$/gi)||"multisigBech32"===addr_decode.type){let s=coinjs.script();s.writeBytes(Crypto.util.hexToBytes(rs)),s.writeOp(0),s.writeBytes(coinjs.numToBytes(value.toFixed(0),8)),script=Crypto.util.bytesToHex(s.buffer)}else script=rs;else{let s=coinjs.script();s.writeOp(118),s.writeOp(169),s.writeBytes(addr_decode.bytes),s.writeOp(136),s.writeOp(172),script=Crypto.util.bytesToHex(s.buffer)}tx.ins[i].script=coinjs.script(script)}tx.witness=!1,console.debug("Unsigned:",tx.serialize()),new Set(wif_keys).forEach((key=>tx.sign(key,1))),resolve(tx.serialize())})).catch((error=>reject(error)))})).catch((error=>reject(error)))}))},btcOperator.editFee_corewallet=function(tx_hex,new_fee,private_keys,change_only=!0){return new Promise(((resolve,reject)=>{Array.isArray(private_keys)||(private_keys=[private_keys]),tx_fetch_for_editing(tx_hex).then((tx=>{parseTransaction(tx).then((tx_parsed=>{if(tx_parsed.fee>=new_fee)return reject("Fees can only be increased");var edit_output_address=new Set;!0===change_only?tx_parsed.inputs.forEach((inp=>edit_output_address.add(inp.address))):!1===change_only?tx_parsed.outputs.forEach((out=>edit_output_address.add(out.address))):"string"==typeof change_only?edit_output_address.add(change_only):Array.isArray(change_only)&&change_only.forEach((id=>edit_output_address.add(id)));let inc_fee=util.BTC_to_Sat(new_fee-tx_parsed.fee);if(inc_fee<219)return reject("Insufficient additional fee. Minimum increment: 219");for(let i=tx.outs.length-1;i>=0&&inc_fee>0;i--)if(edit_output_address.has(tx_parsed.outputs[i].address)){let current_value=tx.outs[i].value;current_value instanceof BigInteger&&(current_value=current_value.intValue()),current_value>inc_fee?(tx.outs[i].value=current_value-inc_fee,inc_fee=0):(inc_fee-=current_value,tx.outs[i].value=0)}if(inc_fee>0){let max_possible_fee=util.BTC_to_Sat(new_fee)-inc_fee;return reject(`Insufficient output values to increase fee. Maximum fee possible: ${util.Sat_to_BTC(max_possible_fee)}`)}tx.outs=tx.outs.filter((o=>o.value>=546));let wif_keys=[],witness_position=0;for(let i in tx.ins){var addr=tx_parsed.inputs[i].address,value=util.BTC_to_Sat(tx_parsed.inputs[i].value);let addr_decode=coinjs.addressDecode(addr);var privKey=private_keys.find((pk=>verifyKey(addr,pk)));if(!privKey)return reject(`Private key missing for ${addr}`);const rs=_redeemScript(addr,privKey);var script;if(!1===rs?wif_keys.unshift(privKey):wif_keys.push(privKey),rs&&rs.length)if(rs.match(/^00/)&&44==rs.length||40==rs.length&&rs.match(/^[a-f0-9]+$/gi)){let s=coinjs.script();s.writeBytes(Crypto.util.hexToBytes(rs)),s.writeOp(0),s.writeBytes(coinjs.numToBytes(value.toFixed(0),8)),script=Crypto.util.bytesToHex(s.buffer),"bech32"==addr_decode&&(witness_position+=1)}else if("multisigBech32"===addr_decode.type){let redeemScript=btcOperator.extractLastHexStrings(tx.witness)[witness_position];witness_position+=1;let s=coinjs.script();s.writeBytes(Crypto.util.hexToBytes(redeemScript)),s.writeOp(0),s.writeBytes(coinjs.numToBytes(value.toFixed(0),8)),script=Crypto.util.bytesToHex(s.buffer)}else script=rs;else{let s=coinjs.script();s.writeOp(118),s.writeOp(169),s.writeBytes(addr_decode.bytes),s.writeOp(136),s.writeOp(172),script=Crypto.util.bytesToHex(s.buffer)}tx.ins[i].script=coinjs.script(script)}tx.witness=!1,console.debug("Unsigned:",tx.serialize()),new Set(wif_keys).forEach((key=>tx.sign(key,1))),btcOperator.checkSigned(tx)?resolve(tx.serialize()):reject("All private keys not present")})).catch((error=>reject(error)))})).catch((error=>reject(error)))}))},btcOperator.sendTx=function(senders,privkeys,receivers,amounts,fee=null,options={}){return options.sendingTx=!0,new Promise(((resolve,reject)=>{createSignedTx(senders,privkeys,receivers,amounts,fee,options).then((result=>{broadcastTx(result.transaction.serialize()).then((txid=>resolve(txid))).catch((error=>reject(error)))})).catch((error=>reject(error)))}))};const createSignedTx=btcOperator.createSignedTx=function(senders,privkeys,receivers,amounts,fee=null,options={}){return new Promise(((resolve,reject)=>{try{({senders:senders,privkeys:privkeys,receivers:receivers,amounts:amounts}=validateTxParameters({senders:senders,privkeys:privkeys,receivers:receivers,amounts:amounts,fee:fee,...options}))}catch(e){return reject(e)}let redeemScripts=[],wif_keys=[];for(let i in senders){let rs=_redeemScript(senders[i],privkeys[i]);redeemScripts.push(rs),!1===rs?wif_keys.unshift(privkeys[i]):wif_keys.push(privkeys[i])}if(redeemScripts.includes(null))return reject("Unable to get redeem-script");createTransaction({senders:senders,redeemScripts:redeemScripts,receivers:receivers,amounts:amounts,fee:fee,change_address:options.change_address||senders[0],...options}).then((result=>{let tx=result.transaction;console.debug("Unsigned:",tx.serialize()),new Set(wif_keys).forEach((key=>tx.sign(key,1))),console.debug("Signed:",tx.serialize()),resolve(result)})).catch((error=>reject(error)))}))};btcOperator.createTx=function(senders,receivers,amounts,fee=null,options={allowUnconfirmedUtxos:!1}){return new Promise(((resolve,reject)=>{try{({senders:senders,receivers:receivers,amounts:amounts}=validateTxParameters({senders:senders,receivers:receivers,amounts:amounts,fee:fee,change_address:options.change_address}))}catch(e){return reject(e)}let redeemScripts=senders.map((id=>_redeemScript(id)));if(redeemScripts.includes(null))return reject("Unable to get redeem-script");createTransaction({senders:senders,redeemScripts:redeemScripts,receivers:receivers,amounts:amounts,fee:fee,change_address:options.change_address||senders[0],...options}).then((result=>{result.tx_hex=result.transaction.serialize(),delete result.transaction,resolve(result)})).catch((error=>reject(error)))}))},btcOperator.createMultiSigTx=function(sender,redeemScript,receivers,amounts,fee=null,options={}){return new Promise(((resolve,reject)=>{let addr_type=validateAddress(sender);if(!["multisig","multisigBech32"].includes(addr_type))return reject("Invalid sender (multisig):"+sender);{let script=coinjs.script(),decode="multisig"==addr_type?script.decodeRedeemScript(redeemScript):script.decodeRedeemScriptBech32(redeemScript);if(!decode||decode.address!==sender)return reject("Invalid redeem-script")}try{({receivers:receivers,amounts:amounts}=validateTxParameters({receivers:receivers,amounts:amounts,fee:fee,change_address:options.change_address}))}catch(e){return reject(e)}createTransaction({senders:[sender],redeemScripts:[redeemScript],receivers:receivers,amounts:amounts,fee:fee,change_address:options.change_address||sender,...options}).then((result=>{result.tx_hex=result.transaction.serialize(),delete result.transaction,resolve(result)})).catch((error=>reject(error)))}))};const deserializeTx=btcOperator.deserializeTx=function(tx){if("string"==typeof tx||Array.isArray(tx))try{tx=coinjs.transaction().deserialize(tx)}catch{throw"Invalid transaction hex"}else if("object"!=typeof tx||"function"!=typeof tx.sign)throw"Invalid transaction object";return tx};btcOperator.signTx=function(tx,privkeys,sighashtype=1){tx=deserializeTx(tx),Array.isArray(privkeys)||(privkeys=[privkeys]);for(let i in privkeys)64===privkeys[i].length&&(privkeys[i]=coinjs.privkey2wif(privkeys[i]));return new Set(privkeys).forEach((key=>tx.sign(key,sighashtype))),tx.serialize()};const checkSigned=btcOperator.checkSigned=function(tx,bool=!0){tx=deserializeTx(tx);let n=[];for(let i in tx.ins){var s=tx.extractScriptKey(i);if("multisig"!==s.type&&"multisig_bech32"!==s.type)n.push("true"==s.signed||tx.witness[i]&&2==tx.witness[i].length);else{var rs=coinjs.script().decodeRedeemScript(s.script);let x={s:s.signatures,r:rs.signaturesRequired,t:rs.pubkeys.length};if(x.r>x.t)throw"signaturesRequired is more than publicKeys";x.s<x.r?n.push(x):n.push(!0)}}return bool?!n.filter((x=>!0!==x)).length:n};btcOperator.checkIfSameTx=function(tx1,tx2){if(tx1=deserializeTx(tx1),tx2=deserializeTx(tx2),tx1.ins.length!==tx2.ins.length||tx1.outs.length!==tx2.outs.length)return!1;for(let i=0;i<tx1.ins.length;i++)if(tx1.ins[i].outpoint.hash!==tx2.ins[i].outpoint.hash||tx1.ins[i].outpoint.index!==tx2.ins[i].outpoint.index)return!1;for(let i=0;i<tx1.outs.length;i++)if(tx1.outs[i].value!==tx2.outs[i].value||Crypto.util.bytesToHex(tx1.outs[i].script.buffer)!==Crypto.util.bytesToHex(tx2.outs[i].script.buffer))return!1;return!0};const getTxOutput=(txid,i)=>new Promise(((resolve,reject)=>{multiApi("tx",{txid:txid}).then((result=>resolve(result.out[i]))).catch((error=>reject(error)))})),parseTransaction=btcOperator.parseTransaction=function(tx){return new Promise(((resolve,reject)=>{tx=deserializeTx(tx);let result={},promises=[];for(let i=0;i<tx.ins.length;i++)promises.push(getTxOutput(tx.ins[i].outpoint.hash,tx.ins[i].outpoint.index));Promise.all(promises).then((inputs=>{result.inputs=inputs.map((inp=>Object({address:inp.addr,value:util.Sat_to_BTC(inp.value)})));let signed=checkSigned(tx,!1);result.inputs.forEach(((inp,i)=>inp.signed=signed[i])),result.outputs=tx.outs.map((out=>{var address;switch(out.script.chunks[0]){case 0:address=util.encodeBech32(Crypto.util.bytesToHex(out.script.chunks[1]),coinjs.bech32.version,coinjs.bech32.hrp);break;case 169:address=util.encodeLegacy(Crypto.util.bytesToHex(out.script.chunks[1]),coinjs.multisig);break;case 118:address=util.encodeLegacy(Crypto.util.bytesToHex(out.script.chunks[2]),coinjs.pub)}return{address:address,value:util.Sat_to_BTC(out.value)}})),result.total_input=parseFloat(result.inputs.reduce(((a,inp)=>a+inp.value),0).toFixed(8)),result.total_output=parseFloat(result.outputs.reduce(((a,out)=>a+out.value),0).toFixed(8)),result.fee=parseFloat((result.total_input-result.total_output).toFixed(8)),resolve(result)})).catch((error=>reject(error)))}))};btcOperator.transactionID=function(tx){tx=deserializeTx(tx);let clone=coinjs.clone(tx);clone.witness=null;let raw_bytes=Crypto.util.hexToBytes(clone.serialize()),txid=Crypto.SHA256(Crypto.SHA256(raw_bytes,{asBytes:!0}),{asBytes:!0}).reverse();return Crypto.util.bytesToHex(txid)};const getTx=btcOperator.getTx=txid=>new Promise((async(resolve,reject)=>{try{const result=await multiApi("tx",{txid:txid});resolve({confirmations:result.confirmations,block:result.block_height,txid:result.hash,time:result.time,size:result.size,fee:util.Sat_to_BTC(result.fee),inputs:result.inputs.map((i=>Object({address:i.prev_out.addr,value:util.Sat_to_BTC(i.prev_out.value)}))),total_input_value:util.Sat_to_BTC(result.inputs.reduce(((a,i)=>a+i.prev_out.value),0)),outputs:result.out.map((o=>Object({address:o.addr,value:util.Sat_to_BTC(o.value)}))),total_output_value:util.Sat_to_BTC(result.out.reduce(((a,o)=>a+o.value),0))})}catch(error){reject(error)}})).catch((error=>reject(error)));getTx.hex=btcOperator.getTx.hex=txid=>multiApi("txHex",{txid:txid}),btcOperator.getAddressData=address=>new Promise(((resolve,reject)=>{Promise.all([multiApi("balance",{addr:address}),multiApi("txs",{addr:address})]).then((([balance,txs])=>{const parsedTxs=txs.map((tx=>function(tx,addressOfTx){const{txid:txid,hash:hash,time:time,block_height:block_height,inputs:inputs,outputs:outputs,out:out,vin:vin,vout:vout,fee:fee,fees:fees,received:received,confirmed:confirmed,status:{block_height:statusBlockHeight,block_time:block_time}={}}=tx;let parsedTx={txid:hash||txid,time:1e3*time||new Date(confirmed||received).getTime()||1e3*block_time||Date.now(),block:block_height||statusBlockHeight,tx_senders:{}};(inputs||vin).forEach((i=>{const address=i.prev_out?.addr||i.addresses?.[0]||i.prev_out?.address||i.addr||i.prevout.scriptpubkey_address,value=i.prev_out?.value||i.output_value||i.value||i.prevout.value;address in parsedTx.tx_senders?parsedTx.tx_senders[address]+=value:parsedTx.tx_senders[address]=value})),parsedTx.tx_input_value=0;for(let senderAddr in parsedTx.tx_senders){let val=parsedTx.tx_senders[senderAddr];parsedTx.tx_senders[senderAddr]=util.Sat_to_BTC(val),parsedTx.tx_input_value+=val}parsedTx.tx_input_value=util.Sat_to_BTC(parsedTx.tx_input_value),parsedTx.tx_receivers={},(outputs||out||vout).forEach((o=>{const address=o.scriptpubkey_address||o.addresses?.[0]||o.scriptpubkey_address||o.addr,value=o.value||o.scriptpubkey_value;address in parsedTx.tx_receivers?parsedTx.tx_receivers[address]+=value:parsedTx.tx_receivers[address]=value})),parsedTx.tx_output_value=0;for(let receiverAddr in parsedTx.tx_receivers){let val=parsedTx.tx_receivers[receiverAddr];parsedTx.tx_receivers[receiverAddr]=util.Sat_to_BTC(val),parsedTx.tx_output_value+=val}return parsedTx.tx_output_value=util.Sat_to_BTC(parsedTx.tx_output_value),parsedTx.tx_fee=util.Sat_to_BTC(fee||fees||parsedTx.tx_input_value-parsedTx.tx_output_value),1===Object.keys(parsedTx.tx_receivers).length&&1===Object.keys(parsedTx.tx_senders).length&&Object.keys(parsedTx.tx_senders)[0]===Object.keys(parsedTx.tx_receivers)[0]?(parsedTx.type="self",parsedTx.amount=parsedTx.tx_receivers[addressOfTx],parsedTx.address=addressOfTx):addressOfTx in parsedTx.tx_senders&&Object.keys(parsedTx.tx_receivers).some((addr=>addr!==addressOfTx))?(parsedTx.type="out",parsedTx.receiver=Object.keys(parsedTx.tx_receivers).filter((addr=>addr!=addressOfTx)),parsedTx.amount=parsedTx.receiver.reduce(((t,addr)=>t+parsedTx.tx_receivers[addr]),0)+parsedTx.tx_fee):(parsedTx.type="in",parsedTx.sender=Object.keys(parsedTx.tx_senders).filter((addr=>addr!=addressOfTx)),parsedTx.amount=parsedTx.tx_receivers[addressOfTx]),parsedTx}(tx,address)));resolve({address:address,balance:balance,txs:parsedTxs})})).catch((error=>reject(error)))})),btcOperator.getBlock=block=>new Promise(((resolve,reject)=>{fetch_api(`rawblock/${block}`).then((result=>resolve({height:result.height,hash:result.hash,merkle_root:result.mrkl_root,prev_block:result.prev_block,next_block:result.next_block[0],size:result.size,time:1e3*result.time,txs:result.tx.map((t=>Object({fee:t.fee,size:t.size,inputs:t.inputs.map((i=>Object({address:i.prev_out.addr,value:util.Sat_to_BTC(i.prev_out.value)}))),total_input_value:util.Sat_to_BTC(t.inputs.reduce(((a,i)=>a+i.prev_out.value),0)),outputs:t.out.map((o=>Object({address:o.addr,value:util.Sat_to_BTC(o.value)}))),total_output_value:util.Sat_to_BTC(t.out.reduce(((a,o)=>a+o.value),0))})))}))).catch((error=>reject(error)))}))}();